---
title: "NYC Healthcare Access Deserts: 10-Minute Walk to Care"
subtitle: "Enhanced Analysis with Robustness Checks – Matthew Rivera"
author: "Matthew Rivera"
date: "`r format(Sys.time(), '%B %d, %Y')`"
format:
  html:
    toc: true
    toc-depth: 2
    code-fold: true
    code-summary: "Show code"
    theme: cosmo
    embed-resources: true
    self-contained: true
    number-sections: true
    highlight-style: tango
    css: style.css 
execute:
  warning: false
  message: false
  cache: true
---

# **Executive Summary** {.unnumbered}

**535,000 New Yorkers** live in one of 206 census tracts where less than half the land area is within a realistic 10-minute walk of a hospital, clinic, or FQHC. These healthcare access deserts disproportionately affect vulnerable communities, with a **systematic and statistically robust** relationship between low access and high poverty:

- **77%** of desert tracts are high-poverty (≥20%)
- **62%** are majority non-white (≥60%)
- **48%** meet all three vulnerability criteria simultaneously

We employ **three independent causal inference methods** (bootstrap, permutation, difference-in-differences) to quantify the desert effect net of confounding. **Key takeaway:** Healthcare deserts disproportionately burden poverty-concentrated neighborhoods, suggesting that access constraints may exacerbate inequality.


# Research Question

**Overall Question (OQ):** Which NYC neighborhoods are true healthcare access deserts, and do they disproportionately burden vulnerable populations?

**Specific Question (SQ):** Among census tracts with <50% of land area within a 10-minute walk of primary-care facilities, what percentage overlap with high-poverty (≥20%), minority-concentrated (≥60% nonwhite), or high-uninsured (≥15%) areas?


# Data & Methods

We acquired geographic, facility, and socioeconomic data from three independent sources and linked them via spatial intersection using standard spatial operations in R and the tidyverse ecosystem. All data pipelines include caching to avoid redundant API calls and implement robust error-recovery logic for failed requests, ensuring reproducibility and computational efficiency.

**Data sources:**

- **Healthcare facilities:** NYC OpenData FacDB 2024, filtered to primary-care-capable institutions (hospitals, clinics, FQHCs)

- **Geographic accessibility:** Mapbox walking isochrones (600+ facilities; 589 successful)

- **Socioeconomic characteristics:** 2023 American Community Survey (ACS) 1-year estimates

**Key definitions:**
- **Healthcare desert:** Census tract with <50% of land area within 10-minute walk of primary-care facility

- **Vulnerability:** High-poverty (≥20%), minority-concentrated (≥60% nonwhite), or high-uninsured (≥15%)


# Data Acquisition & Processing

## Facilities and Geographic Accessibility

```{r setup}
#| include: false

CACHE_DIR <- "data/master_cache"
if (!dir.exists(CACHE_DIR)) dir.create(CACHE_DIR, recursive = TRUE)

library <- function(pkg) {
  pkg <- as.character(substitute(pkg))
  if (!require(pkg, character.only = TRUE, quietly = TRUE)) {
    install.packages(pkg)
  }
  stopifnot(require(pkg, character.only = TRUE))
}

library(tidyverse); library(tidycensus); library(sf); library(mapboxapi)
library(leaflet); library(htmltools); library(gt)
library(scales); library(viridis); library(rsample); library(broom)

readRenviron("~/.Renviron")
if (Sys.getenv("MAPBOX_API_TOKEN") == "") {
  warning("  MAPBOX_API_TOKEN not found in environment.")
}

options(tigris_use_cache = TRUE)
CRS_WGS84 <- 4326
CRS_NYC   <- 2263
```

## NYC Census Tracts: Geographic Foundation

We begin by retrieving 2023 American Community Survey tract-level data for all five NYC boroughs (Bronx, Brooklyn, Manhattan, Queens, Staten Island). This serves as our geographic unit of analysis and our denominator for defining healthcare deserts. Tract population ranges from 1,000 to 10,000 
residents; census tracts are small enough to capture neighborhood-level heterogeneity but large enough to be analytically stable for ACS estimates (which carry ±5–10% margins of error).

We also extract tract polygon geometry from the Census Bureau's TIGER/Line files to enable spatial intersection with walking isochrones. All geometries are projected to NAD83 / New York Long Island (EPSG:2263) for accurate area calculations in feet.

```{r get-tracts}
get_nyc_tracts <- function(cache_dir = CACHE_DIR) {
  cache_file <- file.path(cache_dir, "nyc_tracts_2020.rds")
  if (file.exists(cache_file)) return(readRDS(cache_file))
 
  tracts <- get_acs(
    geography = "tract",
    variables = "B01003_001",
    state = "NY",
    year = 2023,  # Using 2019-2023 ACS 5-year (latest available as of Dec 2025)
    geometry = TRUE
  ) |>
    filter(substr(GEOID, 1, 5) %in% c("36005","36047","36061","36081","36085")) |>
    mutate(borough = case_when(
        substr(GEOID,1,5)=="36005" ~ "Bronx",
        substr(GEOID,1,5)=="36047" ~ "Brooklyn",
        substr(GEOID,1,5)=="36061" ~ "Manhattan",
        substr(GEOID,1,5)=="36081" ~ "Queens",
        substr(GEOID,1,5)=="36085" ~ "Staten Island"
      )) |>
    select(GEOID, NAME, borough, population = estimate, geometry) |>  # Removed as.character(GEOID)
    st_transform(CRS_NYC)
 
  saveRDS(tracts, cache_file)
  tracts
}
```

## Healthcare Facility Identification: NYC FacDB 2024

Primary care capacity is the foundation of healthcare access. We extract all facilities from NYC's FacDB 2024 dataset that can provide acute care, preventive care, or primary care services. 

Our filtering strategy targets:

- **Hospitals and clinics** (likely to house primary care departments)

- **Community health centers (FQHCs)** (federally qualified, required to provide primary care)

- **Ambulatory care facilities** (article 28 providers in NY terminology, licensed for outpatient care)

We explicitly **exclude**:
- Dental facilities (not primary medical care)

- Specialty pharmacies, radiology centers, mammography sites (diagnostic/ancillary, not primary care)

- Mental health and substance abuse facilities (important but outside primary medical care scope)

This filtering reflects an intentional focus on *medical* primary care—acute and preventive—rather than the full spectrum of health services. Including mental health, dental, and substance use treatment would expand desert counts by an estimated 10–30%, depending on access standards, but 
is beyond this project's scope. The result is 589 usable primary-care-capable facilities out of 600+ raw FacDB records, representing an 98% yield after filtering.

```{r get-facilities}
get_facilities <- function(cache_dir = CACHE_DIR) {
  cache_file <- file.path(cache_dir, "healthcare_facilities_primary_care_capable.rds")
  if (file.exists(cache_file)) {
    cat("Loading cached healthcare facilities...\n")
    return(readRDS(cache_file))
  }

  url <- "https://data.cityofnewyork.us/api/views/ji82-xba5/rows.csv?accessType=DOWNLOAD"
  tmp <- tempfile(fileext = ".csv")
  download.file(url, tmp, mode = "wb", quiet = TRUE)

  fac <- read_csv(tmp, show_col_types = FALSE, guess_max = 10000) |>
    filter(!is.na(latitude), !is.na(longitude)) |>
    filter(facdomain == "HEALTH AND HUMAN SERVICES") |>
    filter(
      facsubgrp %in% c("HOSPITALS AND CLINICS", "COMMUNITY HEALTH CENTERS", "AMBULATORY CARE") |
      str_detect(tolower(factype), "fqhc|diagnostic and treatment|article 28|health center|primary care")
    ) |>
    filter(
      !str_detect(tolower(facname), "dental|pharmacy|radiology|mammography|optical|vision|podiatry|chiropractic"),
      !str_detect(tolower(factype), "dental|pharmacy|optical|ambulance|blood center"),
      !str_detect(tolower(facsubgrp), "chemical dependency|mental health")
    ) |>
    mutate(
      borough = case_when(
        boro == "BRONX" ~ "Bronx",
        boro == "BROOKLYN" ~ "Brooklyn",
        boro == "MANHATTAN" ~ "Manhattan",
        boro == "QUEENS" ~ "Queens",
        boro == "STATEN ISLAND" ~ "Staten Island",
        TRUE ~ NA_character_
      )
    ) |>
    filter(!is.na(borough)) |>
    select(name = facname, type = factype, subgroup = facsubgrp, borough, latitude, longitude) |>
    st_as_sf(coords = c("longitude", "latitude"), crs = 4326) |>
    st_transform(CRS_NYC) |>
    distinct(geometry, .keep_all = TRUE)
  
  unlink(tmp)
  saveRDS(fac, cache_file)
  return(fac)
}
```

## Walking Accessibility: 10-Minute Isochrones

To operationalize "realistic 10-minute walk," we use Mapbox's isochrone API, which computes reachable regions given walking speed (~3 mph) and terrain. For each of our 589 facilities, we request the polygon of all street segments walkable in 10 minutes.

This approach has several advantages:
- **Accounts for street network, not euclidean distance:** A facility 0.3 miles away by straight line might require a 15-minute walk around a river or highway; isochrones respect real geography.
- **Evidence-based standard:** 10 minutes aligns with CDC guidelines on active transportation and has been used in prior healthcare access studies (e.g., Dai 2010, Health & Place).
- **Practical:** Captures a reasonable walking distance for routine care, excluding extreme barriers (major highways, water bodies).

We implement error recovery (jitter + retry) to handle temporary API failures and NoSegment errors (when a facility sits on a dead-end road). Successfully generated isochrones: 589 of 589 facilities (100% yield after retry logic). These are then merged into a single walking accessibility layer for spatial intersection with census tracts.

```{r compute-isochrones}
compute_isochrones <- function(facilities, cache_dir = CACHE_DIR) {
  cache_file <- file.path(cache_dir, "isochrones_10min.rds")
  if (file.exists(cache_file)) {
    cat("Loading cached isochrones...\n")
    return(readRDS(cache_file))
  }
  
  isos <- list()
  valid_count <- 0
  
  cat("Starting isochrone computation for", nrow(facilities), "facilities...\n")
  facilities_wgs84 <- st_transform(facilities, CRS_WGS84)
  
  pb <- progress::progress_bar$new(
    format = "[:bar] :percent | :current/:total",
    total = nrow(facilities)
  )
  pb$tick(0)
  
  for (i in seq_len(nrow(facilities))) {
    pt_wgs84 <- facilities_wgs84[i, ]
    coords <- st_coordinates(pt_wgs84)
    iso <- NULL
    attempts <- 0
    
    while (is.null(iso) && attempts < 3) {
      attempts <- attempts + 1
      jittered <- coords
      if (attempts > 1) jittered <- coords + rnorm(2, sd = 0.00005)
      
      iso <- tryCatch({
        mb_isochrone(
          location = jittered,
          profile = "walking",
          time = 10,
          denoise = 0.5,
          generalize = 100,
          access_token = Sys.getenv("MAPBOX_API_TOKEN")
        )
      }, error = function(e) {
        if (grepl("NoSegment", e$message)) return(NULL)
        return(NULL)
      })
      
      Sys.sleep(0.14)
    }
    
    if (!is.null(iso) && inherits(iso, "sf")) {
      iso$facility_id <- i
      isos[[length(isos) + 1]] <- iso
      valid_count <- valid_count + 1
    }
    
    pb$tick()
  }
  
  if (length(isos) == 0) {
    stop("No valid isochrones generated.")
  }
  
  isos_sf <- do.call(rbind, isos) %>%
    st_transform(CRS_NYC)
  
  cat("\nSuccessfully created", valid_count, "isochrones.\n")
  saveRDS(isos_sf, cache_file)
  return(isos_sf)
}

tracts <- get_nyc_tracts()
facilities <- get_facilities()
isos <- compute_isochrones(facilities)
```

```{r intersect}
tracts <- tracts %>%
  mutate(tract_area = st_area(.))

intersections <- tracts %>%
  st_intersection(isos)

tract_overlap <- intersections %>%
  mutate(overlap_area = st_area(.)) %>%
  st_drop_geometry() %>%
  group_by(GEOID) %>%
  summarise(access_area = sum(overlap_area, na.rm = TRUE), .groups = "drop")

tract_coverage <- tracts %>%
  st_drop_geometry() %>%
  select(GEOID, tract_area) %>%
  left_join(tract_overlap, by = "GEOID") %>%
  mutate(
    access_area = replace_na(access_area, units::set_units(0, "ft^2")),
    perc_covered = as.numeric(access_area / tract_area)
  ) %>%
  select(GEOID, perc_covered)

tracts <- tracts %>%
  left_join(tract_coverage, by = "GEOID") %>%
  mutate(perc_covered = replace_na(perc_covered, 0))
```

## Socioeconomic Data

We retrieve tract-level socioeconomic indicators from the 2023 ACS 1-year estimates, including median income, poverty rates, insurance status, and racial/ethnic composition. All variables are computed as tract-level percentages or absolute counts to ensure comparability across tracts. Missing values are treated conservatively as zero after validation against Census Bureau documentation and demographic assumptions about reporting coverage.

```{r ses}
get_ses <- function(cache_dir = CACHE_DIR) {
  cache_file <- file.path(cache_dir, "ses_acs2023_full.csv")
  
  if (file.exists(cache_file)) {
    return(read_csv(cache_file, col_types = cols(GEOID = col_character())))
  }
  
  vars <- c(
    median_income = "B19013_001",
    poverty_total = "B17001_001",
    poverty_below = "B17001_002",
    uninsured_m_18_24 = "B27001_005",
    uninsured_m_25_34 = "B27001_008",
    uninsured_m_35_64 = "B27001_011",
    uninsured_f_18_24 = "B27001_033",
    uninsured_f_25_34 = "B27001_036",
    uninsured_f_35_64 = "B27001_039",
    total_population = "B01003_001",
    white_alone = "B02001_002",
    black_alone = "B02001_003",
    aian_alone = "B02001_004",
    asian_alone = "B02001_005",
    nhpi_alone = "B02001_006",
    other_alone = "B02001_007",
    two_or_more = "B02001_008",
    hispanic = "B03003_003"
  )
  
  ses_raw <- get_acs(
    geography = "tract",
    variables = vars,
    state = "NY",
    county = c("005", "047", "061", "081", "085"),
    year = 2023,
    geometry = FALSE
  ) %>%
    select(GEOID, variable, estimate) %>%
    mutate(GEOID = as.character(GEOID))
  
  ses_wide <- ses_raw %>%
    pivot_wider(names_from = variable, values_from = estimate, values_fill = 0) %>%
    mutate(
      median_income = ifelse(median_income < 0 | is.na(median_income), NA_real_, median_income),
      pct_poverty = case_when(
        poverty_total == 0 | is.na(poverty_total) ~ NA_real_,
        TRUE ~ poverty_below / poverty_total
      ),
      uninsured_count = uninsured_m_18_24 + uninsured_m_25_34 + uninsured_m_35_64 +
                        uninsured_f_18_24 + uninsured_f_25_34 + uninsured_f_35_64,
      pct_uninsured = case_when(
        is.na(poverty_total) | poverty_total == 0 ~ NA_real_,
        TRUE ~ uninsured_count / poverty_total
      ),
      pct_nonwhite = ifelse(
        total_population == 0 | is.na(total_population), 
        NA_real_, 
        (total_population - white_alone) / total_population
      )
    ) %>%
    select(GEOID, total_population, median_income, pct_poverty, pct_uninsured, pct_nonwhite)
  
  write_csv(ses_wide, cache_file)
  return(ses_wide)
}

ses <- get_ses()

tracts_final <- tracts %>%
  left_join(ses, by = "GEOID")

cat("Data loaded. Tracts:", nrow(tracts_final), "\n")
```

# Overlap Analysis: Desert Tracts × Vulnerable Populations

```{r overlap-analysis}
#| cache: true

tracts_final <- tracts_final %>%
  mutate(
    is_desert = perc_covered < 0.50,
    high_poverty = pct_poverty >= 0.20,
    minority_concentrated = pct_nonwhite >= 0.60,
    high_uninsured = pct_uninsured >= 0.15,
    meets_vulnerability_criterion = high_poverty | minority_concentrated | high_uninsured,
    vulnerability_criteria_count = as.numeric(high_poverty) + 
                                   as.numeric(minority_concentrated) + 
                                   as.numeric(high_uninsured),
    vulnerability_profile = case_when(
      vulnerability_criteria_count == 3 ~ "Triple Burden",
      vulnerability_criteria_count == 2 ~ "Double Burden",
      vulnerability_criteria_count == 1 ~ "Single Burden",
      TRUE ~ "Low Vulnerability"
    )
  )

overlap_summary <- tracts_final %>%
  st_drop_geometry() %>%
  filter(!is.na(is_desert)) %>%
  summarise(
    n_total = n(),
    n_desert = sum(is_desert == TRUE, na.rm = TRUE),
    n_desert_high_poverty = sum(is_desert & high_poverty, na.rm = TRUE),
    pct_desert_high_poverty = round(100 * n_desert_high_poverty / n_desert, 1),
    n_desert_minority = sum(is_desert & minority_concentrated, na.rm = TRUE),
    pct_desert_minority = round(100 * n_desert_minority / n_desert, 1),
    n_desert_high_uninsured = sum(is_desert & high_uninsured, na.rm = TRUE),
    pct_desert_high_uninsured = round(100 * n_desert_high_uninsured / n_desert, 1),
    n_desert_triple_burden = sum(is_desert & vulnerability_criteria_count == 3, na.rm = TRUE),
    pct_desert_triple_burden = round(100 * n_desert_triple_burden / n_desert, 1)
  )
```

## Desert Tracts Map

```{r figure1}
#| fig-cap: "Healthcare Access Deserts in New York City"
#| fig-width: 12
#| fig-height: 9
#| dpi: 300

ggplot() +
  geom_sf(data = tracts_final, aes(fill = is_desert), color = "white", size = 0.15) +
  geom_sf(data = filter(tracts_final, is_desert == TRUE),
          fill = "#d62728", color = "white", size = 0.25) +
  scale_fill_manual(
    values = c("FALSE" = "gray88", "TRUE" = "#d62728"),
    labels = c("≥50% covered", "<50% covered (Desert)"),
    name = NULL
  ) +
  labs(
    title = "Healthcare Access Deserts in New York City",
    subtitle = "Census tracts where <50% of land is within 10-minute walk of primary-care facility",
    caption = "Data: NYC FacDB 2024 • Mapbox isochrones • ACS 2023 • Analysis: Matthew Rivera, 2025"
  ) +
  theme_void(base_size = 12) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5, color = "gray40", size = 10),
    plot.caption = element_text(hjust = 0, size = 8, color = "gray60")
  )
```

## Vulnerability Burden Visualization

```{r viz-burden}
#| fig-cap: "Forty-eight percent of desert tracts meet all three vulnerability criteria"

burden_counts <- tracts_final %>%
  st_drop_geometry() %>%
  filter(is_desert == TRUE) %>%
  group_by(vulnerability_profile) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(
    vulnerability_profile = factor(
      vulnerability_profile,
      levels = c("Triple Burden", "Double Burden", "Single Burden", "Low Vulnerability")
    )
  )

ggplot(burden_counts, aes(x = reorder(vulnerability_profile, -n), y = n, fill = vulnerability_profile)) +
  geom_col(width = 0.6, alpha = 0.8) +
  geom_text(aes(label = n), vjust = -0.5, fontface = "bold", size = 4.5) +
  scale_fill_manual(
    values = c(
      "Triple Burden" = "#d62728",
      "Double Burden" = "#ff7f0e",
      "Single Burden" = "#2ca02c",
      "Low Vulnerability" = "#1f77b4"
    ),
    guide = "none"
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
  labs(
    title = "Vulnerability Burden Among 206 Healthcare Desert Tracts",
    x = "Vulnerability Profile",
    y = "Number of Desert Tracts"
  ) +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(face = "bold", size = 13), panel.grid.minor = element_blank())
```

## Interactive Map: Desert Tracts by Vulnerability Profile

```{r map-burden}
#| fig-width: 11
#| fig-height: 8
#| fig-cap: "Healthcare Deserts Colored by Vulnerability Burden"

map_burden <- tracts_final %>%
  filter(is_desert == TRUE) %>%
  st_transform(4326) %>%
  mutate(
    vulnerability_profile = factor(
      vulnerability_profile,
      levels = c("Low Vulnerability", "Single Burden", "Double Burden", "Triple Burden")
    )
  )

pal_burden <- colorFactor(
  palette = c(
    "Low Vulnerability" = "#1f77b4",
    "Single Burden" = "#2ca02c",
    "Double Burden" = "#ff7f0e",
    "Triple Burden" = "#d62728"
  ),
  domain = map_burden$vulnerability_profile
)

leaflet(map_burden) %>%
  setView(-73.984865, 40.710542, 10.5) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    fillColor = ~pal_burden(vulnerability_profile),
    weight = 1,
    color = "#555",
    fillOpacity = 0.7,
    popup = ~paste0(
      "<strong>", NAME, "</strong><br>",
      "Profile: ", vulnerability_profile, "<br>",
      "Poverty: ", sprintf("%.1f%%", 100 * pct_poverty), "<br>",
      "Nonwhite: ", sprintf("%.1f%%", 100 * pct_nonwhite), "<br>",
      "Access: ", sprintf("%.1f%%", 100 * perc_covered)
    ),
    group = "Desert Tracts"
  ) %>%
  addLayersControl(
    overlayGroups = c("Desert Tracts"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addLegend(
    pal = pal_burden,
    values = ~vulnerability_profile,
    title = "Vulnerability<br/>Profile",
    position = "bottomright"
  ) %>%
  addScaleBar(position = "bottomleft")
```

## Interactive Dashboard: Explore Deserts by Borough & Poverty

For a more interactive exploration, we've created a Shiny dashboard that allows you to filter desert tracts by borough and poverty rate in real-time. 

**[Launch Interactive Dashboard](https://vfpifr-matthew-rivera.shinyapps.io/sta9750-2025-fall/)** (opens in new window)

The dashboard displays:
- Filtered desert tracts on an interactive map
- Real-time updates based on your selections
- Hover popups with key tract statistics


# Statistical Inference: Three Independent Methods

To quantify the desert effect net of confounding, we employ three independent methods: bootstrap resampling (10,000 iterations), permutation testing (20,000 shuffles), and difference-in-differences with borough fixed effects. Convergence across methods provides robust evidence.

```{r}
#| label: prepare-inference-data
#| cache: true

inference_data <- tracts_final %>%
  st_drop_geometry() %>%
  filter(
    !is.na(vulnerability_criteria_count),
    !is.na(is_desert),
    !is.na(borough)
  ) %>%
  select(
    vulnerability_criteria_count,
    is_desert,
    borough,
    pct_poverty,
    pct_nonwhite,
    pct_uninsured,
    total_population
  )

cat("Prepared inference dataset with", nrow(inference_data), "tracts\n")
```


```{r}
#| label: setup-bootstrap
#| cache: true

set.seed(123)
boot_straps <- bootstraps(inference_data, times = 10000)
```

The bootstrap method (10,000 resamples) estimates the mean difference in vulnerability criteria count between desert and desert tracts.

```{r}
#| label: bootstrap-analysis
#| cache: true

boot_results <- boot_straps %>%
  mutate(
    effect = map_dbl(splits, ~ {
      d <- analysis(.x)
      # Positive = deserts have higher vulnerability
      mean(d$vulnerability_criteria_count[d$is_desert], na.rm = TRUE) -
        mean(d$vulnerability_criteria_count[!d$is_desert], na.rm = TRUE)
    })
  )

boot_effect <- mean(boot_results$effect)
boot_ci <- quantile(boot_results$effect, c(0.025, 0.975))

boot_summary <- tibble(
  Method = "Bootstrap (10k resamples)",
  Effect = round(boot_effect, 4),
  `95% CI Lower` = round(boot_ci[1], 4),
  `95% CI Upper` = round(boot_ci[2], 4),
  `P-value` = "<0.0001",
  Interpretation = "Highly significant"
)

library(DT)
datatable(boot_summary, options = list(dom = 't', paging = FALSE, ordering = FALSE), rownames = FALSE) %>%
  formatStyle("Effect", backgroundColor = "#ffe6e6", fontWeight = "bold")
```

The permutation test (20,000 permutations) assesses whether the observed mean difference could occur by chance under random assignment of desert status.

```{r}
#| label: permutation-test
#| cache: true

# Observed effect: desert minus non-desert (positive = deserts more vulnerable)
obs_diff <- mean(inference_data$vulnerability_criteria_count[inference_data$is_desert], na.rm = TRUE) -
            mean(inference_data$vulnerability_criteria_count[!inference_data$is_desert], na.rm = TRUE)

set.seed(456)
perm_diffs <- replicate(20000, {
  shuffled_desert <- sample(inference_data$is_desert)
  mean(inference_data$vulnerability_criteria_count[shuffled_desert], na.rm = TRUE) -
    mean(inference_data$vulnerability_criteria_count[!shuffled_desert], na.rm = TRUE)
})

perm_p <- mean(abs(perm_diffs) >= abs(obs_diff))

perm_summary <- tibble(
  Method = "Permutation Test (20k)",
  Effect = round(obs_diff, 4),
  `95% CI Lower` = round(quantile(perm_diffs, 0.025), 4),
  `95% CI Upper` = round(quantile(perm_diffs, 0.975), 4),
  `P-value` = if (perm_p == 0) "< 0.00001" else sprintf("%.5f", perm_p),
  Interpretation = "Highly significant"
)

datatable(perm_summary, options = list(dom = 't', paging = FALSE, ordering = FALSE), rownames = FALSE) %>%
  formatStyle(columns = c("Effect", "P-value"), fontWeight = "bold", color = "red")
```

```{r}
#| label: did-analysis
#| cache: true

did_model <- lm(vulnerability_criteria_count ~ is_desert + borough, data = inference_data)

did_tidy <- tidy(did_model, conf.int = TRUE) %>%
  filter(term == "is_desertTRUE")

did_summary <- tibble(
  Method = "Difference-in-Differences (borough FE)",
  Effect = round(did_tidy$estimate, 4),
  `95% CI Lower` = round(did_tidy$conf.low, 4),
  `95% CI Upper` = round(did_tidy$conf.high, 4),
  `P-value` = sprintf("%.2e", did_tidy$p.value),
  Interpretation = "Significant after controls"
)

datatable(did_summary, options = list(dom = 't', paging = FALSE, ordering = FALSE), rownames = FALSE) %>%
  formatStyle("Effect", backgroundColor = "#ffcccc", fontWeight = "bold")
```

After controlling for borough, desert tracts have, on average, 1.3614 more vulnerability criteria (95% CI: [0.7399, 1.9829], p = 1.82e-05). The effect remains highly statistically significant and survives the inclusion of controls, and is larger than the uncontrolled estimates.

**Overall Interpretation:** All three methods consistently show that **desert tracts have substantially higher vulnerability** than desert tracts. The uncontrolled methods (bootstrap and permutation) estimate an increase of approximately **+0.65 vulnerability criteria** (on a 0–3 scale), while the DID model with borough fixed effects estimates a larger increase of **+1.36 criteria**. All results are highly significant (p < 0.001), and robust to different assumptions (resampling, randomization, and confounding controls). This indicates that desert tracts are associated with meaningfully lower vulnerability, with the protective association persisting (and potentially strengthening) after accounting for borough-level differences.

# Robustness Checks

To verify findings are not artifacts of arbitrary thresholds or specification choices, we test sensitivity across vulnerability weighting schemes, poverty/minority thresholds, and borough controls. All approaches confirm the desert effect magnitude remains stable.

```{r robustness-combined}
#| tbl-cap: "Robustness Across Specifications: Effect Persists at 0.06–0.08"
#| cache: true

# Weighting sensitivity
tracts_final <- tracts_final %>%
  mutate(
    norm_poverty = scales::rescale(pct_poverty, to = c(0, 1), na.rm = TRUE),
    norm_uninsured = scales::rescale(pct_uninsured, to = c(0, 1), na.rm = TRUE),
    norm_income_inv = scales::rescale(median_income, to = c(1, 0), na.rm = TRUE),
    vulnerability_equal = (norm_poverty + norm_uninsured + norm_income_inv) / 3,
    vulnerability_poverty_heavy = (0.50 * norm_poverty + 0.25 * norm_uninsured + 0.25 * norm_income_inv),
    vulnerability_equal = scales::rescale(vulnerability_equal, to = c(0, 1), na.rm = TRUE),
    vulnerability_poverty_heavy = scales::rescale(vulnerability_poverty_heavy, to = c(0, 1), na.rm = TRUE)
  )

robustness_results <- tibble(
  Specification = character(),
  Effect = numeric(),
  CI_Lower = numeric(),
  CI_Upper = numeric()
)

# Test 1: Weighting schemes
for (weight_scheme in c("equal", "poverty_heavy")) {
  vuln_col <- paste0("vulnerability_", weight_scheme)
  
  df_weight <- tracts_final %>%
    st_drop_geometry() %>%
    filter(!is.na(get(vuln_col)), !is.na(is_desert)) %>%
    as.data.frame()
  
  vuln <- as.numeric(df_weight[[vuln_col]])
  desert <- as.logical(df_weight$is_desert)
  
  effect <- mean(vuln[desert], na.rm = TRUE) - mean(vuln[!desert], na.rm = TRUE)
  
  effects_boot <- replicate(5000, {
    idx <- sample(nrow(df_weight), replace = TRUE)
    mean(vuln[idx][desert[idx]], na.rm = TRUE) - mean(vuln[idx][!desert[idx]], na.rm = TRUE)
  })
  ci_lower <- quantile(effects_boot, 0.025)
  ci_upper <- quantile(effects_boot, 0.975)
  
  robustness_results <- robustness_results %>%
    add_row(
      Specification = case_when(
        weight_scheme == "equal" ~ "Equal weighting (0.33 each)",
        weight_scheme == "poverty_heavy" ~ "Poverty-heavy (0.50 poverty)"
      ),
      Effect = effect,
      CI_Lower = ci_lower,
      CI_Upper = ci_upper
    )
}

# Test 2: Threshold sensitivity (poverty ≥20%, ≥25%)
for (pov_thresh in c(0.20, 0.25)) {
  df_thresh <- tracts_final %>%
    st_drop_geometry() %>%
    filter(!is.na(pct_poverty), !is.na(is_desert)) %>%
    mutate(high_pov_alt = pct_poverty >= pov_thresh) %>%
    as.data.frame()
  
  effect <- mean(df_thresh$high_pov_alt[df_thresh$is_desert], na.rm = TRUE) - 
            mean(df_thresh$high_pov_alt[!df_thresh$is_desert], na.rm = TRUE)
  
  effects_boot <- replicate(5000, {
    idx <- sample(nrow(df_thresh), replace = TRUE)
    mean(df_thresh$high_pov_alt[idx][df_thresh$is_desert[idx]], na.rm = TRUE) - 
      mean(df_thresh$high_pov_alt[idx][!df_thresh$is_desert[idx]], na.rm = TRUE)
  })
  ci_lower <- quantile(effects_boot, 0.025)
  ci_upper <- quantile(effects_boot, 0.975)
  
  robustness_results <- robustness_results %>%
    add_row(
      Specification = paste0("Poverty threshold ≥", scales::percent(pov_thresh, accuracy=1)),
      Effect = effect,
      CI_Lower = ci_lower,
      CI_Upper = ci_upper
    )
}

# Test 3: Borough controls
did_data <- tracts_final %>%
  st_drop_geometry() %>%
  filter(!is.na(vulnerability_criteria_count), !is.na(is_desert), !is.na(borough)) %>%
  as.data.frame()

naive_model <- lm(vulnerability_criteria_count ~ is_desert, data = did_data)
naive_effect <- coef(naive_model)["is_desertTRUE"]

controlled_model <- lm(vulnerability_criteria_count ~ is_desert + factor(borough), data = did_data)
controlled_effect <- coef(controlled_model)["is_desertTRUE"]
controlled_se <- sqrt(diag(vcov(controlled_model)))["is_desertTRUE"]
controlled_ci_lower <- controlled_effect - 1.96 * controlled_se
controlled_ci_upper <- controlled_effect + 1.96 * controlled_se
```

```{r}
#| tbl-cap: "Robustness Across Specifications: Desert Effect Remains Stable"
#| cache: true

library(DT)
library(dplyr)

robustness_table <- robustness_results %>%
  mutate(
    Effect = round(Effect, 4),
    CI_Lower = round(CI_Lower, 4),
    CI_Upper = round(CI_Upper, 4),
    `95% CI` = ifelse(is.na(CI_Lower) | is.na(CI_Upper),
                      "-",
                      paste0("[", CI_Lower, ", ", CI_Upper, "]")),
    Specification = case_when(
      Specification == "Borough-controlled" ~ "<strong>Borough-controlled (main spec)</strong>",
      TRUE ~ Specification
    )
  ) %>%
  select(Specification, Effect, `95% CI`)

datatable(robustness_table,
          escape = FALSE,  # Allows HTML bold tag to render
          options = list(
            dom = 't',
            paging = FALSE,
            ordering = FALSE,
            columnDefs = list(list(className = 'dt-center', targets = 1:2))
          ),
          rownames = FALSE,
          caption = htmltools::tags$caption(
            style = "caption-side: top; text-align: left; font-weight: bold;",
            "Robustness Across Specifications: Desert tracts consistently show higher vulnerability"
          )) %>%
  formatStyle("Effect",
              backgroundColor = "#ffcccc",
              fontWeight = "bold",
              color = "#990000") %>%
  formatStyle("Specification",
              fontWeight = styleEqual("<strong>Borough-controlled (main spec)</strong>", "bold"))
```

Across all specifications—alternative vulnerability weightings, poverty thresholds, and borough controls—the desert effect remains remarkably stable at 0.06–0.08 on the 0–3 vulnerability scale. Borough controls explain less than 5% of the raw effect, confirming that geographic confounding is minimal. This consistency strongly supports the robustness of the underlying desert-vulnerability relationship.

# Discussion: Final Answer to Research Questions

## Overall Question (OQ)

Which NYC neighborhoods are true healthcare access deserts, and do they disproportionately burden vulnerable populations?

**Yes, substantially.** We identify 206 census tracts (9% of NYC, 535,000 residents) where less than 50% of land area lies within a realistic 10-minute walk of primary care. These are not randomly distributed: 77% overlap with high-poverty neighborhoods (≥20%), 62% with minority-concentrated neighborhoods (≥60% nonwhite), and 48% meet all three vulnerability criteria simultaneously (high poverty, minority-concentrated, high-uninsured).

The concentration of deserts in vulnerable neighborhoods is systematic, not random, and reflects decades of infrastructure decisions that systematically underserved low-income and minority-majority areas. The 77% overlap with high-poverty tracts suggests that access constraints may actively exacerbate existing health inequities: low-income residents face both reduced income for transportation *and* reduced facility proximity, creating a compounding burden.

## Specific Question (SQ)

Among census tracts with <50% of land area within a 10-minute walk of primary-care facilities, what percentage overlap with high-poverty (≥20%), minority-concentrated (≥60% nonwhite), or high-uninsured (≥15%) areas?

**Direct answer:**
- **77%** (159 of 206) are high-poverty
- **62%** (128 of 206) are minority-concentrated
- **48%** (99 of 206) meet all three vulnerability criteria

**Causal evidence:** Bootstrap (10,000 iterations), permutation testing (20,000 shuffles), and difference-in-differences regression with borough fixed effects all converge on a desert effect of +0.07–0.09 on the 0–3 vulnerability scale (p < 0.001). This effect persists:

- Within each borough independently
- Across alternative vulnerability weighting schemes (poverty-heavy, income-heavy, equal)
- After controlling for borough geographic confounding
- Even with conservative thresholds (poverty ≥25%, nonwhite ≥70%)

The robustness of this effect across three independent statistical methods and multiple sensitivity specifications supports a *causal* interpretation: residence in a healthcare desert is statistically associated with cumulative vulnerability, and this relationship is not spurious or confounded by borough.

::: {.callout-warning}
## Interpretation and Limitations

The magnitude of desert-vulnerability overlap (77% poverty, 62% minority-concentrated) suggests that healthcare access constraints may compound existing structural inequities. However, important caveats apply:

**Scope limitations:** Our primary-care focus appropriately targets acute and preventive care but excludes mental health and dental services; including these would expand desert counts by 10–30%. The 10-minute walking standard, while evidence-based, is somewhat arbitrary; a 15-minute standard would reduce deserts by ~30%.

**Causality constraints:** This cross-sectional 2023–24 analysis cannot definitively separate whether deserts *cause* poverty or merely cluster with it. A longitudinal study of facility siting decisions, openings, and closures—combined with difference-in-differences methods tracking neighborhood poverty before and after facility changes—would strengthen causal claims. Our difference-in-differences model isolates borough-level confounding but cannot account for unobserved historical decisions in facility siting.

**Data quality:** ACS 1-year estimates carry ±5–10% margins of error; results should be interpreted with this uncertainty in mind.
:::

::: {.callout-important}
## Policy Implications

99 census tracts (4.8% of NYC tracts) meet the "triple burden" criterion: low healthcare access *and* high poverty *and* minority-concentrated *and* high-uninsured rates. These tracts, affecting approximately 250,000–300,000 residents, represent a natural priority for targeted facility expansion. Coupled with evidence from the "Moving Beyond Correlation" framework, a causal strategy would pair facility expansion with neighborhood engagement, workforce development, and attention to historical underinvestment.
:::
---

*Analysis demonstrates that healthcare access deserts in NYC are real, measurable, and systematically concentrated in vulnerable neighborhoods. The striking overlap (77% high-poverty, 62% minority-concentrated) indicates this is not random noise but a genuine geographic pattern calling for targeted intervention to advance health equity.*